<!doctype html>
<!--
  - Copyright (c) 2014-2016 Cloudware S.A. All rights reserved.
  -
  - This file is part of casper-common-ui.
  -
  - casper-common-ui is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-common-ui  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-common-ui.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer-element.html">

<!--
`casper-socket`

https://javascript.info/async-await

websocket client for casper server
-->

<dom-module id="casper-socket">

  <script>

    class CasperSocket extends Polymer.Element {

      static get is () {
        return 'casper-socket';
      }

      static get properties () {
        return {
          /** websocket schema + hostname (no port no path) */
          url: {
            type: String
          },
          /** websocket port number, defaults to current page port */
          port: {
            type: String
          },
          /** Path or route that connects to casper-epaper module */
          path: {
            type: String
          },
          /** Sec-WebSocket-Protocol */
          webSocketProtocol: {
            type: String,
            value:  'casper-epaper'
          },
          /** Tube prefix */
          tubePrefix: {
            type: String,
            value: 'casper',
            observer: '_onTubePrefixChanged'
          },
          /** Define to use cookies valid for all sub domains of this domain */
          cookieDomain: {
            type: String,
            value: undefined
          },
          /** Default timeout for server requests in seconds */
          defaultTimeout: {
            type: Number,
            value: 10
          }
        }
      }

      /**
       * @brief Assign defaults to undefined component attributes
       */
      constructor () {
        super();
        if ( this.url === undefined ) {
          if ( window.location.protocol === 'https:' ) {
            this.url = 'wss://' + window.location.hostname;
          } else {
            this.url = 'ws://' + window.location.hostname;
          }
        }
        this.port = this.port || window.location.port;
        this.path = this.path || 'epaper';

        if ( this.cookieDomain === undefined ) {
          let domain = window.location.hostname.split('.');
          if (domain.length >= 3 ) {
            domain.shift();
          }
          this.cookieDomain = domain.join('.');
        }
        this._sessionCookieParser = new RegExp('.*casper_session=([0-9a-zA-Z]+)');
        this._issuerCookieParser = new RegExp('.*casper_issuer=([:\/\.0-9a-zA-Z]+)');

        this._boundMouseOutListener    = this._mouseOutListener.bind(this);
        this._boundUserActivity        = this.userActivity.bind(this);
        this._boundUserActivity        = this.userActivity.bind(this);
        this._boundApplicationInactive = this.applicationInactive.bind(this);
      }

      connectedCallback () {
        this._initData();
        this._silentDisconnect = false;
        this._socket = undefined;

        document.addEventListener('mouseout', this._boundMouseOutListener);
        document.addEventListener('click',    this._boundUserActivity);
        document.addEventListener('keypress', this._boundUserActivity);
        window.addEventListener('blur',       this._boundApplicationInactive);
      }

      _mouseOutListener (event) {
        if (event.toElement == null && event.relatedTarget == null) {
          this.applicationInactive(event);
        }
      }

      disconnectedCallback () {
        this._clearData();
        this.disconnect();
        document.removeEventListener('mouseout', this._boundMouseOutListener);
        document.removeEventListener('click',    this._boundUserActivity);
        document.removeEventListener('keypress', this._boundUserActivity);
        window.removeEventListener('blur',       this._boundApplicationInactive);
      }

      connect () {
        this._ws_url = this.url + ((this.port != undefined && this.port !== '') ? ':' + this.port : '') + '/' + this.path;
        if (typeof MozWebSocket != "undefined") {
          this._socket = new MozWebSocket(this._ws_url, this.webSocketProtocol);
        } else {
          this._socket = new WebSocket(this._ws_url, this.webSocketProtocol);
        }
        this._socket.onmessage = this._onSocketMessage.bind(this);
        this._socket.onopen    = this._onSocketOpen.bind(this);
        this._socket.onclose   = this._onSocketClose.bind(this);
      }

      /**
       * Terminate connection to casper server
       */
      disconnect () {
        if ( this._socket ) {
          this._socket.close();
          this._socket = undefined;
        }
      }

      isOpen () {
        if ( this._socket === undefined ) {
          return false;
        } else {
          return this._socket.readyState === 1;
        }
      }

      submitJob (job, handler, options) {
        let timeout;

        // .. set all keys that will be automatically replaced with session values
        job['user_id']          = null;
        job['entity_id']        = null;
        job['entity_schema']    = null;
        job['sharded_schema']   = null;
        job['subentity_id']     = null;
        job['subentity_schema'] = null;
        job['subentity_prefix'] = null;
        job['user_email']       = null;

        let target  = {target: 'job-queue', tube: job.tube};
        if ( options ) {
          if ( options.ttr ) {
            target.ttr = options.ttr;
          }
          if ( options.validity ) {
            target.validity = options.validity;
          }
          timeout = options.timeout;
          if ( options.overlay ) {
            this._showOverlay(options.overlay);
          }
        }
        timeout = timeout || this.defaultTimeout;
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), timeout * 1000);
        let request = { job: job, callback: this._submitJobResponse.bind(this), options: options, handler: handler, invokeId: ivk, timer: tid };
        this._send(ivk + ':PUT:' + JSON.stringify(target)+':'+JSON.stringify(job));
        this._activeRequests.set(ivk, request);
      }

      _submitJobResponse (response, request) {
        if ( response.success === true && response.channel ) {
          request.channel = response.channel;
          this._subscriptions.set(response.channel, { handler: request.handler, timer: request.timer, invokeId: request.invokeId, confirmed: true });
        } else {
          request.handler({
              message: ['O servidor recusou o pedido, p.f. tente mais tarde'],
              status: 'error',
              status_code: 500
            });
        }
      }

      subscribeJob (jobId, handler, timeout) {
        let p = jobId.split(':');
        timeout = timeout || this.defaultTimeout;
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), timeout * 1000);
        let request = { tube: p[0], id: p[1], callback: this._subscribeJobResponse.bind(this), handler: handler, invokeId: ivk, timer: tid };
        this._send(ivk + ':SUBSCRIBE:' + JSON.stringify({ target: 'job', tube: request.tube, id: request.id }));
        this._activeRequests.set(ivk, request);
      }

      _subscribeJobResponse (response, request) {
        request.channel = response.channel;
        if ( response.success === true && response.channel ) {
          this._subscriptions.set(response.channel, { handler: request.handler, timer: request.timer, invokeId: request.invokeId, confirmed: true });
        } else {
          request.handler({
              message: ['O servidor recusou o pedido, p.f. tente mais tarde'],
              status: 'error',
              status_code: 500
            });
        }
      }

      cancelJob (jobId, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let p = jobId.split(':');
        let request = { tube: p[0], id: p[1], callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':CANCEL:' + JSON.stringify({ target: 'job-queue', tube: request.tube, id: request.id }));
        this._activeRequests.set(ivk, request);
      }

      //***************************************************************************************//
      //                                                                                       //
      //                            ~~~ Login and Logout ~~~                                   //
      //                                                                                       //
      //***************************************************************************************//

      loginListener (notification) {
        try {
          if ( notification.status === 'completed' && notification.status_code === 200 ) {
            this.saveSessionCookie(notification.response.access_token, notification.response.access_ttl, notification.response.issuer_url);
            this._silentDisconnect = true;
            this.disconnect();
            window.location = notification.response.url;
          } else if ( notification.status === 'error' ) {
            if ( notification.status_code === 401 ) {
              this.dispatchEvent(new CustomEvent('casper-forbidden', {bubbles: true, composed: true, detail: { message: notification.message }}));
            } else {
              this.dispatchEvent(new CustomEvent('casper-error', {bubbles: true, composed: true, detail: { message: notification.message }}));
            }
          }
        } catch (exception) {
          console.log(exception);
          this.dispatchEvent(new CustomEvent('casper-error', {bubbles: true, composed: true, detail: { message: notification.message }}));
        } finally {
          this.disconnect();
        }
      }

      signOut () {
        let failed = false;

        try {
          if ( this.sessionCookie ) {
                this.submitJob({
                tube:          this._logoutQueue,
                access_token:  null,
                refresh_token: null
              },
              this._signOutResponse.bind(this), {
                ttr: 90,
                validity: 120
              }
            );
          }
        } catch (exception) {
          // ... ignore and proceed with the the logout
          failed = true;
        } finally {
          this.wipeCredentials();
        }
        if ( failed ) {
          this.dispatchEvent(new CustomEvent('casper-signed-out', {bubbles: true, composed: true}));
        }
      }

      _signOutResponse (response) {
        this.dispatchEvent(new CustomEvent('casper-signed-out', {bubbles: true, composed: true}));
        this.disconnect();
        window.location = '/login';
      }

      /**
       * Validate the current access token, retrieve access token (session) from cookie and set on websocket
       */
      validateSession () {
        const accessToken = this.sessionCookie;

        if ( accessToken ) {
          this._setSession(accessToken, this._validateSessionResponse.bind(this));
        } else {
          this.deleteSessionCookie();
          this.dispatchEvent(new CustomEvent('casper-signed-out', {bubbles: true, composed: true}));
        }
      }

      /**
       * Send the command that sets the current session on the casper server websocket context
       *
       * @param {String}   accessToken the session indentifier
       * @param {function} callback function that will be called (bound to receiver)
       */
      _setSession (accessToken, callback) {
        this._accessToken = accessToken;
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { access_token: accessToken, callback: callback, invokeId: ivk, timer: tid };
        this._send(ivk + ':SET:{"target":"session"}:' + JSON.stringify(request));
        this._activeRequests.set(ivk, request);
      }

      /**
       * Handle the set session response returned by the server
       *
       * @param {object} response the server response to the set session command
       */
      _validateSessionResponse (response) {
        if ( response.success === false ) {
          this._accessToken = undefined;
          this.deleteSessionCookie();
          this.dispatchEvent(new CustomEvent('casper-signed-out', { bubbles: true, composed: true }));
        } else {
          if ( response.refresh_token ) {
            window.localStorage.setItem('casper-refresh-token', response.refresh_token);
          }
          if ( response.entity_id ) {
            window.localStorage.setItem('casper-last-entity-id', response.entity_id);
          }
          if ( response.user_email ) {
            this._updateEmailNotifications(response.user_email);
            this.savedEmail = response.user_email;
          }
          this.dispatchEvent(new CustomEvent('casper-signed-in', { bubbles: true, composed: true, detail: response }));
        }
      }

      extendSession () {
        this.submitJob({
            tube:          this.extendTube,
            access_token:  null
          },
          this._extendSessionResponse.bind(this), {
            ttr: Math.max(this.defaultTimeout - 5, 5),
            validity: this.defaultTimeout,
            timeout: this.defaultTimeout
          }
        );
      }

      _extendSessionResponse (response) {
        if ( response.status === 'completed' && response.status_code === 200 ) {
          this.saveSessionCookie(response.response.access_token, response.response.access_ttl, response.response.issuer_url);
          this.validateSession();
          return;
        } else {
          window.location = '/login';
        }
      }


      //***************************************************************************************//
      //                                                                                       //
      //                              ~~~ Entity switching ~~~                                 //
      //                                                                                       //
      //***************************************************************************************//

      switchToEntity (entityId, redirectUrl, subEntityId) {
        this.submitJob({
            tube:          this._switchEntityQueue,
            access_token:  null,             // will be set by server from session data
            refresh_token: null,             // will be set by server from session data
            to_entity_id:  entityId,         // id of the entity we'll switch to
            url:           redirectUrl       // URL to load after the switch is made
          },
          this._switchEntityListener.bind(this), {
            ttr: 60,
            validity: 70,
            timeout: 10,
            overlay: {
              message: 'A mudar de empresa',
              spinner: true,
              icon: 'switch'
            }
          }
        );
      }

      _switchEntityListener (notification) {
        if ( notification.status === 'completed' && notification.status_code === 200 ) {
          if ( notification.response.url[0] === '/' ) {
            // ... we are on the same cluster ...
            this._switchResponse = notification.response;
            this._setSession(notification.response.access_token, this._validateSwitchSessionResponse.bind(this));
          } else {
            // ... we moved to another cluster ...
            this.saveSessionCookie(notification.response.access_token, notification.response.access_ttl, notification.response.issuer_url);
            window.location = notification.response.url;
          }
        } else {
          this._showOverlay({message: 'falhou a mudança de empresa', icon: 'error' });
        }
      }

      _validateSwitchSessionResponse (response) {
        if ( response.success === false ) {
          this.deleteSessionCookie();
          this.dispatchEvent(new CustomEvent('casper-signed-out', {bubbles: true, composed: true}));
        } else {
          if ( this._switchResponse !== undefined ) {
            this._accessToken = this._switchResponse.access_token;
            this.saveSessionCookie(this._switchResponse.access_token, this._switchResponse.access_ttl, this._switchResponse.issuer_url);
            if ( this._switchResponse.user_email ) {
              this._updateEmailNotifications(response.user_email);
              this.savedEmail = this._switchResponse.user_email;
            }
            if ( response.refresh_token ) {
              window.localStorage.setItem('casper-refresh-token', response.refresh_token);
            }
            if ( response.entity_id ) {
              window.localStorage.setItem('casper-last-entity-id', response.entity_id);
            }
          }
          response.url = this._switchResponse.url;
          this.dispatchEvent(new CustomEvent('casper-signed-in', {
              bubbles: true,
              composed: true,
              detail: response
            })
          );
        }
        this._switchResponse = undefined;
      }

      switchToSubEntity (subEntityType, subEntityId, redirectUrl) {
        this.submitJob({
            tube:            this._switchSubEntityQueue,
            access_token:    null,             // will be set by server from session data
            refresh_token:   null,             // will be set by server from session data
            url:             redirectUrl,      // URL to load after the switch is made
            to_subtype:      subEntityType,    // Subentity type
            to_subentity_id: subEntityId       // Subentity identifier
          },
          this._switchEntityListener.bind(this), {
            ttr: 60,
            validity: 70,
            timeout: 10,
            overlay: {
              message: 'A mudar ano fiscal',
              spinner: true,
              icon: 'switch'
            }
          }
        );
      }

      //***************************************************************************************//
      //                                                                                       //
      //                               ~~~ Documents ~~~                                       //
      //                                                                                       //
      //***************************************************************************************//

      /**
       * Open document template
       */
      openDocument (chapterModel, clientCallback, documentHandler) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { timer: tid, invokeId: ivk, callback: function (response) {
                                    if ( undefined != response.id ) {
                                      this._documents.set(response.id, documentHandler);
                                    }
                                    clientCallback(response);
                                  }.bind(this) };
        let options = { target: "document" }
        this._send(ivk + ':OPEN:' + JSON.stringify(options) + ':' + JSON.stringify(chapterModel));
        this._activeRequests.set(ivk, request);
      }

      loadDocument (chapterModel, clientCallback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: clientCallback , timer: tid, invokeId: ivk };
        let options = { target: "document", id: chapterModel.id }
        this._send(ivk + ':LOAD:' + JSON.stringify(options) + ':' + JSON.stringify(chapterModel));
        this._activeRequests.set(ivk, request);
      }

      reloadDocument (id, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options = { target: "document", id: id }
        this._send(ivk + ':RELOAD:' + JSON.stringify(options));
        this._activeRequests.set(ivk, request);
      }

      closeDocument (id, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options;
        if ( undefined != id ) {
          options = { target: "document", id: id }
        } else {
          options = { target: "document" }
        }
        this._send(ivk + ':CLOSE:' + JSON.stringify(options));
        this._activeRequests.set(ivk, request);
      }

      sendKey (id, key, modifier, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options = { target: "document", id: id };
        let command = { input: { key: key }};
        if ( modifier ) {
          command.input.modifier = modifier;
        }
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      moveCursor (id, motion, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options = { target: "document", id: id };
        let command = { input: { motion: motion }};
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      setText (id, value, motion, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options = { target: "document", id: id };
        let command = { input: { text: value }};
        if ( motion ) {
          command.input.motion = motion;
        }
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      setTextT (id, value, motion, final, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: callback, timer: tid, invokeId: ivk };
        let options = { target: "document", id: id };
        let command = { input: { text: value, final_update: final }};
        if ( motion ) {
          command.input.motion = motion;
        }
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      sendClick (id, x, y, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { input: { click: { x: x, y: y }}};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      gotoPage (id, pageNumber, focus, callback) {  // focus???
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { properties: { page: pageNumber }};
        let request = { callback: callback, timer: tid, invokeId: ivk };

        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      setScale (id, scale, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { properties: { scale: scale }};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      setEditable (id, editable, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { properties: { editable: editable }};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      setListValue (id, value, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { input: { text: value, key: 'save' }};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':SET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      getNotifications (channel, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { invokeId: ivk, timer: tid, callback: function (response) {
               try {
                 let notifications = [];
                 for ( var m of response.members ) {
                   notifications.push(JSON.parse(m));
                 }
                 callback(notifications);
               } catch (e) {
                 callback([]);
               }
             }.bind(this)
          };
        let options = { target: "notifications", channel: channel };
        this._send(ivk + ':GET:' + JSON.stringify(options));
        this._activeRequests.set(ivk, request);
      }

      subscribeNotifications (channel, id, handler) {
        let ivk = this._selectInvokeId();
        let chn = channel + ':' + id;
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let request = { callback: this._subscribeNotificationsResponse.bind(this), channel: chn, handler: handler, timer: tid, invokeId: ivk };
        this._send(ivk + ':SUBSCRIBE:' + JSON.stringify({ target: 'notifications', channel: channel, id: id }));
        this._activeRequests.set(ivk, request);
        this._subscriptions.set(channel + ':' + id, { handler: handler, timer: tid, invokeId: ivk, confirmed: false, notification: true});
      }

      _subscribeNotificationsResponse (response, request) {
        let subscription = undefined;

        if ( request.channel ) {
          subscription = this._subscriptions.get(request.channel);
          if ( subscription ) {
            if ( response.success === true ) {
              subscription.timer     = undefined;
              subscription.invokeId  = undefined;
              subscription.confirmed = true;
              return;
            }
          }
        }
        // cleanup
        if ( subscription ) {
          if ( subscription.handler ) {
            subscription.handler("failed"); // TODO normalize response
          }
          this._subscriptions.delete(request.channel);
        }
      }

      _unsubscribeNotifications (channel, id, handler) {
        /*let ivk = this._selectInvokeId();
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':UNSUBSCRIBE:' + JSON.stringify({ target: 'notifications', channel: channel, id: id }));
        this._activeRequests.set(ivk, request);*/
      }

      /**
       * Requests the server side hint for the current hovering point
       *
       * @param {number} id document identifier
       * @param {number} x coordinate where the mouse is overing
       * @param {number} y coordinate where the mouse is overing
       * @param {function} bound response handler to callback
       */
      getHint (id, x, y, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { hint: { x: 1.0 * x.toFixed(2), y: 1.0 * y.toFixed(2) }};
        let request = { callback: callback, timer: tid, invokeId: ivk  };
        this._send(ivk + ':GET:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      addBand (id, type, bandId, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { band: { type: type, id: bandId}};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':ADD:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      deleteBand (id, type, bandId, callback) {
        let ivk = this._selectInvokeId();
        let tid = setTimeout(() => this._timeoutHandler(ivk), this.defaultTimeout * 1000);
        let options = { target: "document", id: id };
        let command = { band: { type: type, id: bandId}};
        let request = { callback: callback, timer: tid, invokeId: ivk };
        this._send(ivk + ':REMOVE:' + JSON.stringify(options) + ':' + JSON.stringify(command));
        this._activeRequests.set(ivk, request);
      }

      //***************************************************************************************//
      //                                                                                       //
      //                               ~~~ Internal methods ~~~                                //
      //                                                                                       //
      //***************************************************************************************//

      /**
       * Send text message to casper server
       *
       * @param {String} message the plain text message to send
       */
      _send (message) {
        if ( this._socket === undefined || this._socket.readyState !== 1 ) {
          this._pendingCommands.push(message);
          this.connect()
        } else if (this._socket.readyState === 1 ) {
          this._socket.send(message);
        }
      }

      /**
       * Assigns the next invoke id for communication with the server
       */
      _selectInvokeId () {
        if ( this._freedInvokes.length === 0 ) {
          return this._nextInvokeId++;
        } else {
          return this._freedInvokes.shift()
        }
      }

      _onSocketOpen (event) {
        if ( this._pendingCommands.length !== 0 ) {
          for (let message of this._pendingCommands) {
            this._socket.send(message);
          }
          this._pendingCommands = [];
        }
        this.dispatchEvent(new CustomEvent('casper-connected', {bubbles: true, composed: true}));
      }

      _onSocketClose (event) {
        if ( this._silentDisconnect !== true ) {
          this.dispatchEvent(new CustomEvent('casper-disconnected', {bubbles: true, composed: true, detail: { message: 'casper-disconnected', icon: 'sleep'} } ));
        }
        this._silentDisconnect = false;
        this._socket = undefined;
      }

      /**
       * Message decoder and handler, decodes the JSON payloads and delivers the message to the clients
       *
       * @param {Object} message the web socket message
       */
      _onSocketMessage (message) {
        try {
          let request, payload, invokeId, timerId, releaseInvoke = true;

          const data  = message.data;
          const start = data.indexOf('0:N:{');
          if ( start === 0 ) {
            const end = data.indexOf('"}:{"');
            if ( -1 !== end ) {
              const channel = data.substring(16,end);
              const notification = JSON.parse(data.substring(end+3));
              const subscription = this._subscriptions.get(channel);

              if ( subscription ) {
                timerId = subscription.timer;
                if ( timerId ) {
                  if ( notification.status !== 'in-progress' ) {

                    let request = this._activeRequests.get(subscription.invokeId);
                    if ( request ) {
                      if ( request.options && request.options.overlay ) {
                        if ( notification.status === 'error') {
                          this._showOverlay({ message: notification.message[0], icon: 'error' });
                        } else if ( notification.status === 'completed' ) {
                          this._dismissOverlay();
                        }
                      }
                      this._activeRequests.delete(invokeId);
                    }
                    clearTimeout(timerId);
                    this._subscriptions.delete(channel);
                    this._freedInvokes.push(subscription.invokeId);
                    console.log('--- Closing channel ', channel, ' open timerId=', timerId, ' invokeId', subscription.invokeId);
                  }
                  if (subscription.confirmed && subscription.handler) {
                    subscription.handler(notification);
                  } else {
                    console.log("**** subscription no longer active:", channel);
                  }
                } else {
                  if ( subscription.confirmed && subscription.notification && subscription.handler ) {
                    console.warn('This a real notification ', channel);
                    subscription.handler(notification);
                  } else {
                    console.warn('**** subscription no longer active: ' + channel);
                  }
                }
              } else {
                console.warn("**** subscription no longer active:", channel);
              }
            } else {
              console.error("Yikes! Protocol decoding error");
            }
            return;
          }

          invokeId = parseInt(data);
          if ( !isNaN(invokeId) ) {
            const offset = invokeId.toString().length;
            if ( data.substring(offset, offset+ 3) === ':D:' || data.substring(offset, offset+3) === ':n:') {
              const documentHandler = this._documents.get(invokeId);
              if ( documentHandler ) {
                documentHandler(data.substring(offset+1));
              }
            } else {
              request = this._activeRequests.get(invokeId);
              if ( request !== undefined ) {
                let payload_start;

                timerId = request.timer;
                if ( (payload_start = data.indexOf(':R:{')) === offset ) {
                  payload = JSON.parse(data.substring(payload_start + 3));
                } else if ((payload_start = data.indexOf(':S:{')) === offset) {
                  payload = JSON.parse(data.substring(payload_start + 3));
                } else if ((payload_start = data.indexOf(':E:{')) === offset) {
                  payload = JSON.parse(data.substring(payload_start + 3));
                } else {
                  // Unknown message ignore
                  console.error('casper protocol decoding error!!!');
                }
                if ( ! (payload.channel && timerId && ( !payload.status || payload.status.status === 'in-progress' ))) {
                  // ... release the invoke ...
                  if ( timerId ) {
                    clearTimeout(timerId);
                  }
                  this._activeRequests.delete(invokeId);
                  this._freedInvokes.push(invokeId);
                }

                if ( payload && request.callback !== undefined ) {
                  request.callback(payload, request);
                  return;
                }
              } else {
                this._freedInvokes.push(invokeId);
              }
            }
          }
        } catch (exception) {
          console.log(exception);
        }
        return;
      }

      /**
       * Handle request timeouts
       *
       * @param {Integer} invokeId the invoke identifier associated with the original request
       */
      _timeoutHandler (invokeId) {

        console.log("**** Timeout for invoke ", invokeId);

        const request = this._activeRequests.get(invokeId);
        if ( request !== undefined ) {
          if ( request.handler !== undefined ) {
            request.handler({
              message: ['i18n_server_timeout'],
              status: 'error',
              status_code: 504
            });
          }
          this._activeRequests.delete(invokeId);
          this._freedInvokes.push(invokeId);
          if ( request.channel ) {
            this._subscriptions.delete(request.channel);
          }
        }
        this._showOverlay({ message: 'Tempo de espera ultrapassado', icon: 'timeout' });
      }

      /**
       * Clears timers and internal data
       */
      _clearData () {
        for ( let request of this._activeRequests.values() ) {
          if ( request.timer ) {
            clearTimeout(request.timer);
          }
        }
        this._activeRequests.clear();
        this._documents.clear();
        this._subscriptions.clear(); // TODO KEEP NOTIFICATIONS
        this._initData();
      }

      /**
       * Initializes internal data structures
       */
      _initData () {
        this._savedEmail      = undefined;  // The email used to sign-in
        this._accessToken     = undefined;  // The current access token in use
        this._pendingCommands = [];         // Commands waiting for session establishment
        this._freedInvokes    = [];         // keeps the invokes that were returned by the server
        this._activeRequests  = new Map();  // hash, key is the Invoke value the request in flight
        this._documents       = new Map();
        this._nextInvokeId    = 1;          // The next fresh invoke ID
        this._subscriptions   = new Map();  // Registry of server subscriptions, key is channel
      }

      /**
       * Observer to initialize the beanstalkd tube names
       */
      _onTubePrefixChanged () {
        this.loginTube             = this.tubePrefix + '-login';
        this.refreshTube           = this.tubePrefix + '-token-refresh';
        this.extendTube            = this.tubePrefix + '-session-extend';
        this._switchEntityQueue    = this.tubePrefix + '-switch-entity';
        this._switchSubEntityQueue = this.tubePrefix + '-switch-subentity';
        this._logoutQueue          = this.tubePrefix + '-logout';
      }

      /**
       * Helper to bring the overlay that blocks the user interface
       *
       * @param {Object} detail
       */
      _showOverlay (detail) {
        this.dispatchEvent(new CustomEvent('casper-show-overlay', {
            bubbles: true,
            composed: true,
            detail: detail
          })
        );
       }

      /**
       * Helper to dismiss the overlay that blocks the user interface
       */
      _dismissOverlay () {
        this.dispatchEvent(new CustomEvent('casper-dismiss-overlay', {
            bubbles: true,
            composed: true
          })
        );
      }

      _updateEmailNotifications (userEmail) {
        if ( this._savedEmail !== userEmail ) {
          // TODO unsubscribe email this._unsubscribeNotifications('email', _savedEmail);
          this.subscribeNotifications('email', userEmail, function (notification) {
            if ( notification.access_token && this._accessToken && this._accessToken !== notification.access_token ) {
              console.log("Shoot dam user created a new session on my back!!! ", notification.access_token);
            }
          }.bind(this));
        }
      }

      userActivity (event) {
        console.log('user Active ', event);
      }

      applicationInactive (event) {
        console.log('application Inactive ', event);
      }

      //***************************************************************************************//
      //                                                                                       //
      //                      ~~~ Cookie and local storage handling ~~~                        //
      //                                                                                       //
      //***************************************************************************************//

      saveCookie (name, value, ttl) {
        let cookie = `${name}=${value};path=/`;

        if ( window.location.protocol === 'https:' ) {
          cookie += ';secure=true';
        }
        if ( this.cookieDomain ) {
          cookie += `;domain=${this.cookieDomain}`;
        }
        if ( ttl ) {
          let now = new Date();
          now.setSeconds(now.getSeconds() + ttl);
          cookie += `;expires=${now.toUTCString()}`
        }
        cookie += ';';
        document.cookie = cookie;
      }

      /**
       * Clears a cookie
       */
      deleteCookie (name) {
        let cookie = `${name}=`;
        if ( this.cookieDomain ) {
          cookie += `;domain=${this.cookieDomain}`;
        }
        cookie += ';path=/;expires=Thu, 01 Jan 2018 00:00:01 GMT;'
        document.cookie = cookie;
      }

      /**
       * Save session cookie with the current access token
       *
       * @param accessToken the access token generated by the server
       * @param ttl Time to live how long the token should live in seconds
       * @param issuer_url the URL of the server that issued the access token
       */
      saveSessionCookie (accessToken, ttl, issuer_url) {
        this.saveCookie('casper_session', accessToken, ttl);
        if ( issuer_url ) {
          this.saveCookie('casper_issuer', issuer_url);
        }
      }

      /**
       * Retrieve the session cookie that contains the access token aka casper-session
       */
      get sessionCookie () {
        const match = this._sessionCookieParser.exec(document.cookie);
        if ( match && match.length === 2 && match[1].length >= 16 ) {
          return match[1];
        } else {
          return undefined;
        }
      }

      /**
       * Retrieve the URL of the machine that issued the last token
       */
      get issuerUrl () {
        const match = this._issuerCookieParser.exec(document.cookie);
        if ( match && match.length === 2 && match[1].length >= 16 ) {
          return match[1];
        } else {
          return undefined;
        }
      }

      /**
       * Clears the cookie that contains the access token aka casper-session
       */
      deleteSessionCookie () {
        this.deleteCookie('casper_session');
      }

      /**
       *  Wipe stored credentials
       */
      wipeCredentials () {
        this.deleteCookie('casper_issuer');
        this.deleteSessionCookie();
        window.localStorage.removeItem('casper-user-email');
        window.localStorage.removeItem('casper-refresh-token');
      }

      /**
       * Retrieve saved email
       */
      get savedEmail () {
        return this._savedEmail || window.localStorage.getItem('casper-user-email');
      }

      /**
       * Save user email
       */
      set savedEmail (email) {
        if ( this._savedEmail !== email ) {
          window.localStorage.setItem('casper-user-email', email);
          this._savedEmail = email;
        }
      }

      /**
       * Retrieve saved credential
       */
      get savedCredential () {
        return window.localStorage.getItem('casper-refresh-token');
      }

    }

    window.customElements.define(CasperSocket.is, CasperSocket);
  </script>
</dom-module>
